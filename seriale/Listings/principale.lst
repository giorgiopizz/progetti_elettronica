C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/04/2019 10:26:50 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PRINCIPALE
OBJECT MODULE PLACED IN .\Objects\principale.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE principale.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\principale.lst) TABS(2) OBJECT(.\Objects\principale.obj)

line level    source

   1          #include "c8051F020.h"
   2          #define CR 13
   3          #define LF 10
   4          #define ML 10
   5          #define n_loops 5
   6          //ML ? Max Lenght
   7          /*il programma ha 3 sezioni, divise dallo switch in scelta. Nella prima il micro trasmette un messaggio
   8          di benvenuto, nella seconda trasmetto i caratteri ricevuto, uno alla volta, nella terza memorizza
   9          10 caratteri(al massimo) per poi trasmetterli. Per passare da una modalit? all'altra si usa il #*/
  10          typedef unsigned char uchar;
  11          extern void Init_Device();
  12          idata stack[16];
  13          
  14          //dico che non mi interessa la comunicazione multiprocessore
  15          uchar key;
  16          
  17          uchar idata msg_da_trasmettere[]={'C','i','a','o',CR,LF};
  18          uchar lenght_da_trasmettere = 6;
  19          uchar idata msg_errore[]={CR,LF,'E','r','r','o','r','e',CR,LF};
  20          uchar lenght_errore=10;
  21          //uchar lenght_max = 10;
  22          
  23          uchar i=0;
  24          uchar * puntatore;
  25          uchar idata msg_ricevuto[ML+4];
  26          uchar status=0;
  27          uchar loaded=0;
  28          
  29          //variabili led
  30          /*
  31          int luminosity = 0;
  32          int loops_on;
  33          int loops; //lo stato iniziale ? 1
  34          int led_status=0;
  35          int lum_status=0;*/
  36          
  37          /*la trasmissione inizia quando un byte viene scritto nel SBUF0
  38          viene lanciato un interrupt quando ? finita la trasmissione e viene settato
  39          il flag TI0.
  40          Per la ricezione bisogna settare REN0(SCON0.4) ad 1. Finisce quando riceve
  41          il bit di stop, quest'ultimo a seconda che SM20 sia settato ad 1 o a 0 deve
  42          essere 1 o 0*/
  43          
  44          void scelta(void){
  45   1        //controllo lo status
  46   1        switch(status){
  47   2          case(0):
  48   2            //trasmetto il messaggio di benvenuto
  49   2            i++;
  50   2            if (i<lenght_da_trasmettere){
  51   3              SBUF0=*(puntatore+i);
  52   3            }
  53   2            else{
  54   3              //vado a ricevere
C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/04/2019 10:26:50 PAGE 2   

  55   3              status++;
  56   3              i=0;
  57   3              REN0=1;
  58   3            }
  59   2            break;
  60   2          case(1):
  61   2            //ricevo
  62   2            //leggo SBUF0
  63   2            key=SBUF0;
  64   2            RI0=0;
  65   2            if(key=='#'){
  66   3              i=2;
  67   3              status++;
  68   3              //*puntatore=msg_ricevuto[0];
  69   3            }
  70   2            else{
  71   3              if(!loaded){
  72   4                loaded=1;
  73   4                SBUF0=key;
  74   4              }
  75   3            }
  76   2            break;
  77   2            
  78   2          case(2):
  79   2            RI0=0;
  80   2            if(i<ML+3){
  81   3              key=SBUF0;
  82   3              //aggiungo il carattere letto al vettore
  83   3              msg_ricevuto[i]=key;
  84   3              i++;
  85   3              if(key=='#'){
  86   4                //smetto di ricevere
  87   4                REN0=0;
  88   4                status=0;
  89   4                puntatore=msg_ricevuto;
  90   4                msg_ricevuto[i-1]=CR;
  91   4                msg_ricevuto[i]=LF;
  92   4                lenght_da_trasmettere=i+1;
  93   4                i=0;
  94   4                //trasmetto il messaggio ricevuto
  95   4                SBUF0=*puntatore;
  96   4              }
  97   3            }
  98   2            else{
  99   3              REN0=0;
 100   3              i=0;
 101   3              status=0;
 102   3              //trasmetto il messaggio di errore
 103   3              puntatore=msg_errore;
 104   3              lenght_da_trasmettere=lenght_errore;
 105   3              SBUF0=*puntatore;
 106   3            }
 107   2            break;
 108   2        }
 109   1      }
 110          
 111          void UARTO() interrupt 4{
 112   1      
 113   1        if(TI0==1){
 114   2          //allora ho appena finito di trasmettere
 115   2          scelta();
 116   2          loaded=0;
C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/04/2019 10:26:50 PAGE 3   

 117   2          //resettare flag
 118   2          TI0=0;
 119   2          return;
 120   2        }
 121   1        else if(RI0==1){
 122   2          //allora ho appena finito di ricevere
 123   2          scelta();
 124   2          return;
 125   2        }
 126   1        else{
 127   2          //ho un problema
 128   2          return;
 129   2        }
 130   1      }
 131          
 132          //aggiungo le funzionalit? del led
 133          /*
 134          void interruzione_timer(void) interrupt 1{
 135            //fermo
 136            TR0=0;
 137            TF0=0;
 138            loops--;
 139            if (loops<=0){
 140                if(led_status){
 141                  //accendo
 142                  P1_6=1;
 143                  led_status=0;
 144                  loops=loops_on;
 145                }
 146                else{
 147                  //spengo
 148                  P1_6=0;
 149                  led_status=1;
 150                  loops=n_loops-loops_on;
 151                  //faccio ripartire
 152                }
 153            }
 154            TR0=1;
 155          }
 156          void interruzione_pulsante(void) interrupt 19{
 157            TR0=0;
 158            TF0=0;
 159            //lum status  pu? essere 0, 1, 2,3,4
 160            if(lum_status<4){
 161              lum_status++;
 162            }
 163            else{
 164              lum_status=0;
 165            }
 166            luminosity=lum_status*25;
 167            loops_on=n_loops*luminosity/100;
 168            //resetto tutto
 169            loops=loops_on;
 170            led_status=0;
 171            P1_6=1;
 172            
 173          //  se volessi resettare il flag dell'interrupt esterna 7
 174          //  dovrei scrivere
 175            P3IF &= ~0x80;
 176          //  ? necessario rimettere a 1 il flag della porta P3.7
 177          //  anche se probabilmente schiacciando il bottone verr?
 178          //  in automatico settato a 1 dopo
C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/04/2019 10:26:50 PAGE 4   

 179            //P3_7=0;
 180            //poi pu? rincominciare
 181            TR0=1;
 182          }*/
 183          /*trasmettere benvenuto da micro, e poi aspetta in modalit? eco*/
 184          void main(){
 185   1        SP=(char)&stack;
 186   1        Init_Device();
 187   1        /*loops_on=n_loops*luminosity/100;
 188   1        loops=loops_on;*/
 189   1        //inizio con la trasmissione del messaggio di benvenuto
 190   1        puntatore = msg_da_trasmettere; 
 191   1        SBUF0=*puntatore;
 192   1        msg_ricevuto[0]=CR;
 193   1        msg_ricevuto[1]=LF;
 194   1        
 195   1        while(1);
 196   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    261    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9    ----
   IDATA SIZE       =     62    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
