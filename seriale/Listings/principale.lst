C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/16/2019 17:20:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE PRINCIPALE
OBJECT MODULE PLACED IN .\Objects\principale.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE principale.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\principale.lst) TABS(2) OBJECT(.\Objects\principale.obj)

line level    source

   1          //#include "c8051F020.h"
   2          //#define CR 13
   3          //#define LF 10
   4          //#define ML 10
   5          //#define n_loops 5
   6          ////ML ? Max Lenght
   7          ///*il programma ha 3 sezioni, divise dallo switch in scelta. Nella prima il micro trasmette un messaggio
   8          //di benvenuto, nella seconda trasmetto i caratteri ricevuto, uno alla volta, nella terza memorizza
   9          //10 caratteri(al massimo) per poi trasmetterli. Per passare da una modalit? all'altra si usa il #*/
  10          //typedef unsigned char uchar;
  11          //extern void Init_Device();
  12          //idata stack[16];
  13          
  14          ////dico che non mi interessa la comunicazione multiprocessore
  15          //uchar key;
  16          //uchar idata msg_da_trasmettere[]={'C','i','a','o',CR,LF};
  17          //uchar lenght_da_trasmettere = 6;
  18          //uchar idata msg_errore[]={CR,LF,'E','r','r','o','r','e',CR,LF};
  19          //uchar lenght_errore=10;
  20          //uchar i=0;
  21          //uchar * puntatore;
  22          //uchar idata msg_ricevuto[ML+4];
  23          //uchar status=0;
  24          //uchar loaded=0;
  25          
  26          ////variabili led
  27          ///*
  28          //int luminosity = 0;
  29          //int loops_on;
  30          //int loops; //lo stato iniziale ? 1
  31          //int led_status=0;
  32          //int lum_status=0;*/
  33          
  34          ///*la trasmissione inizia quando un byte viene scritto nel SBUF0
  35          //viene lanciato un interrupt quando e finita la trasmissione e viene settato
  36          //il flag TI0.
  37          //Per la ricezione bisogna settare REN0(SCON0.4) ad 1. Finisce quando riceve
  38          //il bit di stop, quest'ultimo a seconda che SM20 sia settato ad 1 o a 0 deve
  39          //essere 1 o 0*/
  40          
  41          //void scelta(void){
  42          //  //controllo lo status
  43          //  switch(status){
  44          //    case(0):
  45          //      //trasmetto il messaggio di benvenuto
  46          //      i++;
  47          //      if (i<lenght_da_trasmettere){
  48          //        SBUF0=*(puntatore+i);
  49          //      }
  50          //      else{
  51          //        //vado a ricevere
  52          //        status++;
  53          //        i=0;
  54          //        REN0=1;
C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/16/2019 17:20:16 PAGE 2   

  55          //      }
  56          //      break;
  57          //    case(1):
  58          //      //ricevo
  59          //      //leggo SBUF0
  60          //      key=SBUF0;
  61          //      RI0=0;
  62          //      if(key=='#'){
  63          //        i=2;
  64          //        status++;
  65          //        //*puntatore=msg_ricevuto[0];
  66          //      }
  67          //      else{
  68          //        if(!loaded){
  69          //          loaded=1;
  70          //          SBUF0=key;
  71          //        }
  72          //      }
  73          //      break;
  74          //      
  75          //    case(2):
  76          //      RI0=0;
  77          //      if(i<ML+3){
  78          //        key=SBUF0;
  79          //        //aggiungo il carattere letto al vettore
  80          //        msg_ricevuto[i]=key;
  81          //        i++;
  82          //        if(key=='#'){
  83          //          //smetto di ricevere
  84          //          REN0=0;
  85          //          status=0;
  86          //          puntatore=msg_ricevuto;
  87          //          msg_ricevuto[i-1]=CR;
  88          //          msg_ricevuto[i]=LF;
  89          //          lenght_da_trasmettere=i+1;
  90          //          i=0;
  91          //          //trasmetto il messaggio ricevuto
  92          //          SBUF0=*puntatore;
  93          //        }
  94          //      }
  95          //      else{
  96          //        REN0=0;
  97          //        i=0;
  98          //        status=0;
  99          //        //trasmetto il messaggio di errore
 100          //        puntatore=msg_errore;
 101          //        lenght_da_trasmettere=lenght_errore;
 102          //        SBUF0=*puntatore;
 103          //      }
 104          //      break;
 105          //  }
 106          //}
 107          
 108          //void UARTO() interrupt 4{
 109          //  if(TI0==1){
 110          //    //ho appena finito di trasmettere
 111          //    scelta();
 112          //    //dice che ha caricato l'ultimo carattere
 113          //    loaded=0; 
 114          //    //resettare flag
 115          //    TI0=0;
 116          //    return;
C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/16/2019 17:20:16 PAGE 3   

 117          //  }
 118          //  else if(RI0==1){
 119          //    //ho appena finito di ricevere
 120          //    scelta();
 121          //    return;
 122          //  }
 123          //  else{
 124          //    //ho un problema
 125          //    return;
 126          //  }
 127          //}
 128          
 129          ////aggiungo le funzionalita del led
 130          ///*
 131          //void interruzione_timer(void) interrupt 1{
 132          //  //fermo
 133          //  TR0=0;
 134          //  TF0=0;
 135          //  loops--;
 136          //  if (loops<=0){
 137          //      if(led_status){
 138          //        //accendo
 139          //        P1_6=1;
 140          //        led_status=0;
 141          //        loops=loops_on;
 142          //      }
 143          //      else{
 144          //        //spengo
 145          //        P1_6=0;
 146          //        led_status=1;
 147          //        loops=n_loops-loops_on;
 148          //        //faccio ripartire
 149          //      }
 150          //  }
 151          //  TR0=1;
 152          //}
 153          //void interruzione_pulsante(void) interrupt 19{
 154          //  TR0=0;
 155          //  TF0=0;
 156          //  //lum status  pu? essere 0, 1, 2,3,4
 157          //  if(lum_status<4){
 158          //    lum_status++;
 159          //  }
 160          //  else{
 161          //    lum_status=0;
 162          //  }
 163          //  luminosity=lum_status*25;
 164          //  loops_on=n_loops*luminosity/100;
 165          //  //resetto tutto
 166          //  loops=loops_on;
 167          //  led_status=0;
 168          //  P1_6=1;
 169          //  
 170          ////  se volessi resettare il flag dell'interrupt esterna 7
 171          ////  dovrei scrivere
 172          //  P3IF &= ~0x80;
 173          ////  ? necessario rimettere a 1 il flag della porta P3.7
 174          ////  anche se probabilmente schiacciando il bottone verr?
 175          ////  in automatico settato a 1 dopo
 176          //  //P3_7=0;
 177          //  //poi pu? rincominciare
 178          //  TR0=1;
C51 COMPILER V9.59.0.0   PRINCIPALE                                                        11/16/2019 17:20:16 PAGE 4   

 179          //}*/
 180          ///*trasmettere benvenuto da micro, e poi aspetta in modalit? eco*/
 181          //void main(){
 182          //  SP=(char)&stack;
 183          //  Init_Device();
 184          //  /*loops_on=n_loops*luminosity/100;
 185          //  loops=loops_on;*/
 186          //  //inizio con la trasmissione del messaggio di benvenuto
 187          //  puntatore = msg_da_trasmettere; 
 188          //  SBUF0=*puntatore;
 189          //  msg_ricevuto[0]=CR;
 190          //  msg_ricevuto[1]=LF;
 191          //  
 192          //  while(1);
 193          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
